<?xml version="1.0" encoding="utf-8"?>
<ctl:package 
	xmlns:ctl="http://www.occamlab.com/ctl" 
	xmlns:parsers="http://www.occamlab.com/te/parsers" 
	xmlns:ocp="http://www.occamlab.com/te/parsers" 
	xmlns:tep="http://teamengine.sourceforge.net/parsers" 
	xmlns:sml="http://www.opengis.net/sensorml/2.0"
	xmlns:swe="http://www.opengis.net/swe/2.0" 
	xmlns:gml="http://www.opengis.net/gml/3.2" 
	xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xlink="http://www.w3.org/1999/xlink" 
	xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
	xmlns="http://www.w3.org/1999/xhtml" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:smlFunctions="https://cite.opengeospatial.org/sml-2.0.0/src/ctl/functions.xml">

	<ctl:suite name="sml:suite">
		<ctl:title>SensorML 2.0 Compliance Test Suite</ctl:title>
		<ctl:description>Verifies that an SensorML 2.0 implementation complies with the Sensor Model Language (SensorML) Implementation Specification.</ctl:description>
		<ctl:starting-test>sml:Main</ctl:starting-test>
	</ctl:suite>

	<ctl:test name="sml:Main">
		<ctl:assertion>The schema satisfies all applicable assertions.</ctl:assertion>
		<ctl:code>
			<!--
                1.)  Prompt the user to provide the url for an SensorML implementation.
                2.)  Send a request to the provided url to determine if there is a response
                3.)  If there is a response, then begin executing tests, else fail.
            -->
			<ctl:message>**********************************************************************</ctl:message>
			<ctl:message>Testing started at:  <xsl:value-of select="current-dateTime()" />
			</ctl:message>
			<ctl:message>**********************************************************************</ctl:message>
			<xsl:variable name="form-values">
				<ctl:form height="700" width="1024">
					<body>
						<h2>Compliance Test Suite for Sensor Model Language (SensorML) 2.0</h2>
						<p>
                  Please provide a URL from which a SensorML document can 
                  be retrieved. Modify the URL template below to specify the 
                  location of an OGC SensorML 2.0 implementation to be tested.
						</p>
						<blockquote>
							<table border="1" padding="4" bgcolor="#99ccff">
								<tr>
									<td align="left">
										<b>SensorML URL:</b>
									</td>
									<td align="center">
										<input name="service-url" size="128" type="text" value="" />
									</td>
								</tr>
							</table>
						</blockquote>
						<blockquote>
							<table border="1" padding="4" bgcolor="#00ffff" align="center">
								<tr>
									<td>
										<input type="submit" value="Start" />
									</td>
								</tr>				
							</table>						
						</blockquote>
						<blockquote>
							<p>
								<h3>SensorML URL Example:</h3>
								a SensorML with a public URL ( The root element is "sml:SensorML"). <br />
								For example:<br />
								<a target="_blank" href="https://raw.githubusercontent.com/opengeospatial/ets-sensorml20/master/src/main/example/SensorML2_1.xml">
								https://raw.githubusercontent.com/opengeospatial/ets-sensorml20/master/src/main/example/SensorML2_1.xml</a><br />
								<a target="_blank" href="https://raw.githubusercontent.com/opengeospatial/ets-sensorml20/master/src/main/example/SensorML2_2.xml">
								https://raw.githubusercontent.com/opengeospatial/ets-sensorml20/master/src/main/example/SensorML2_2.xml</a>
							</p>
						</blockquote>
					</body>
				</ctl:form>
			</xsl:variable>
			<!-- Get user input:  Get the value of the SensorML URL that the user supplies -->
			<xsl:variable name="sml.get.url" select="$form-values/values/value[@key='service-url']" />
			<ctl:message>Executing tests on the SensorML implementation found at the following URL:  <xsl:value-of select="$sml.get.url" />
			</ctl:message>
			<ctl:call-test name="sml:ConformanceValidation">
				<ctl:with-param name="serviceURL" select="$sml.get.url" />
			</ctl:call-test>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:ConformanceValidation">
		<ctl:param name="serviceURL" />
		<ctl:assertion>The provided SensorML complies with the SensorML 2.0 Implementation Specification.</ctl:assertion>
		<ctl:code>
			<ctl:message>Executing a request for getting the context of the provided SensorML from "<xsl:value-of select="$serviceURL" />"</ctl:message>
			<xsl:variable name="response">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$serviceURL" />
					</ctl:url>
					<ctl:method>get</ctl:method>
					<parsers:XMLValidatingParser>
						<parsers:schemas>
							<parsers:schema type="resource">xsd\w3c\xml.xsd</parsers:schema>
							<parsers:schema type="resource">xsd\ogc\sensorML\2.0\sensorML.xsd</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>
				</ctl:request>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>FAILURE: Missing or invalid response entity.</ctl:message>
					<ctl:fail />
				</xsl:when>
				<xsl:otherwise>
					<ctl:message select="'******************** Req03 ********************'"/>
					<ctl:call-test name="sml:Req03">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req14 ********************'"/>
					<ctl:call-test name="sml:Req14">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req40 ********************'"/>
					<ctl:call-test name="sml:Req40">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<!--
					<ctl:message select="'******************** Req46 ********************'"/>
					<ctl:call-test name="sml:Req46">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					-->
					<ctl:message select="'******************** Req47 ********************'"/>
					<ctl:call-test name="sml:Req47">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req52 ********************'"/>
					<ctl:call-test name="sml:Req52">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req53 ********************'"/>
					<ctl:call-test name="sml:Req53">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req55 ********************'"/>
					<ctl:call-test name="sml:Req55">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req56 ********************'"/>
					<ctl:call-test name="sml:Req56">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req57 ********************'"/>
					<ctl:call-test name="sml:Req57">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req58 ********************'"/>
					<ctl:call-test name="sml:Req58">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req61 ********************'"/>
					<ctl:call-test name="sml:Req61">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req65 ********************'"/>
					<ctl:call-test name="sml:Req65">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req71 ********************'"/>
					<ctl:call-test name="sml:Req71">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req74 ********************'"/>
					<ctl:call-test name="sml:Req74">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req75 ********************'"/>
					<ctl:call-test name="sml:Req75">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req77 ********************'"/>
					<ctl:call-test name="sml:Req77">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<!--
					<ctl:message select="'******************** Req78 ********************'"/>
					<ctl:call-test name="sml:Req78">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					-->
					<ctl:message select="'******************** Req81 ********************'"/>
					<ctl:call-test name="sml:Req81">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
					<ctl:message select="'******************** Req82 ********************'"/>
					<ctl:call-test name="sml:Req82">
						<ctl:with-param name="response" select="$response" />
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req03">
		<ctl:param name="response" />
		<ctl:assertion>The core model for a process shall include a unique ID for distinguishing that process from all others.</ctl:assertion>
		<ctl:code>
			<ctl:message>Inspect the schema or encoding definition to verify that the process includes a unique ID.</ctl:message> 
			<xsl:choose>
				<xsl:when test="count($response/gml:identifier) > 0">
					<ctl:message>PASS:  There is a "gml:identifier" element under the root element. The process include a unique ID. </ctl:message> 
				</xsl:when>
				<xsl:when test="count($response/@gml:id) > 0">
					<ctl:message>PASS:  There is a gml:id attribute at the root element. The process include a unique ID. </ctl:message> 
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>FAILURE:  The SensorML did not include a unique ID. </ctl:message> 
					<ctl:message>There should have a "gml:identifier" element or a "gml:id" attribute at root element.</ctl:message>
					<ctl:fail />
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>
	
	<ctl:test name="sml:Req14">
		<ctl:param name="response" />
		<ctl:assertion>A process that is a specific instance of another process shall reference the more general process through its typeOf property. 
The value of the typeOf property shall be a resolvable link to an instance of a process derived from AbstractProcess.</ctl:assertion>
		<ctl:code>
			<ctl:message>Inspect the schema or encoding definition to verify that the typeOf property is a resolvable URL that references an instance of a process.</ctl:message> 
			<xsl:choose>
				<xsl:when test="count($response//sml:typeOf) > 0">
					<ctl:message>There is one or more "typeOf" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:typeOf">
						<xsl:variable name="href" select="./@xlink:href" />
						<ctl:message>href:  "<xsl:value-of select="$href" />" </ctl:message> 
						<xsl:if test="not(smlFunctions:isValidURL($href) eq 'true')">
							<ctl:message>FAILURE:  The xlink:href "<xsl:value-of select="$href" />" attribute of the typeOf element is not a resolvable URL. </ctl:message> 
							<ctl:fail />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no typeOf element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
			
		</ctl:code>
	</ctl:test>
	
	<ctl:test name="sml:Req40">
		<ctl:param name="response" />
		<ctl:assertion>A ModeChoice instantiation shall include two or more mode properties.</ctl:assertion>
		<ctl:code>
			<ctl:message>Inspect the schema or encoding definition to verify that it includes two or more mode properties.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:ModeChoice) > 0">
					<ctl:message>There is one or more "ModeChoice" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:ModeChoice">
						<xsl:variable name="mode" select=".//sml:mode" />
						<xsl:if test="not(count($mode) > 1)">
							<ctl:message>FAILURE:  There is only <xsl:value-of select="count($mode)" /> sml:mode element in the sml:ModeChoice element. It should be two or more. </ctl:message> 
							<ctl:fail />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no ModeChoice element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>
	
	<ctl:test name="sml:Req47">
		<ctl:param name="response" />
		<ctl:assertion>The value of the extension property shall be a schema in which the root element is defined in a new unique namespace (other than the namespaces used by this standard and its dependencies). </ctl:assertion>
		<ctl:code>
			<ctl:message>Test the value of the extension property to determine that the namespace of the root element is not http://schemas.opengis.net/sensorml/*.</ctl:message>
			
			<xsl:choose>
				<xsl:when test="count($response//sml:extension) > 0">
					<xsl:variable name="root" select="$response//sml:extension/*[1]" />
					<ctl:message>element:  "<xsl:value-of select="name($root)" />" </ctl:message> 
					<xsl:if test="starts-with(name($root), 'sml')">
						<ctl:message>FAILURE:  The namespace of the first element of the extension property should not be http://schemas.opengis.net/sensorml/*</ctl:message> 
						<ctl:fail />
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no extension element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req52">
		<ctl:param name="response" />
		<ctl:assertion>An instance supporting DescribedObject shall have one and only one gml:identifier and this element shall have a codespace attribute with a value set to “uniqueID”. 
The value of the gml:identifier shall be a globally unique identifier for the DescribedObject.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate the XML Instance contains a unique ID for gml:identifier based on a well-defined protocol and that the value of the codespace attribute is “uniqueID”.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response/gml:identifier) > 1">
					<ctl:message>FAILURE:  There are more than one gml:identifier element. </ctl:message> 
					<ctl:fail />
				</xsl:when>
				<xsl:when test="count($response/gml:identifier) > 0">
					<xsl:variable name="codeSpace" select="$response/gml:identifier/@codeSpace" />
					<xsl:if test="not($codeSpace eq 'uid') and not($codeSpace eq 'uniqueID')">
						<ctl:message>FAILURE:  The value:"<xsl:value-of select="$codeSpace" />" of the codespace attribute should be 'uniqueID' ( or 'uid' ). </ctl:message> 
						<ctl:fail />
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no gml:identifier element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req53">
		<ctl:param name="response" />
		<ctl:assertion>All values for the securityConstraints property shall be defined in a new unique namespace (other than the namespaces used by this standard and its dependencies).</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate that the XML Instance does not use the http://schemas.opengis.net/sensorml/* namespace for the value of the securityConstraints property.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:securityConstraints) > 0">
					<xsl:variable name="root" select="$response//sml:securityConstraints/*[1]" />
					<ctl:message>element:  "<xsl:value-of select="name($root)" />" </ctl:message> 
					<xsl:if test="starts-with(name($root), 'sml')">
						<ctl:message>FAILURE:  The namespace of the first element of the securityConstraints property should not be http://schemas.opengis.net/sensorml/*</ctl:message> 
						<ctl:fail />
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no securityConstraints element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req55">
		<ctl:param name="response" />
		<ctl:assertion>The role of the responsible party relative to the described object shall be provided using the xlink:arcrole attribute of the relevant member property of the ContactList.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate within the XML Instance that either xlink:arcrole or xlink:role attribute is present in the member element of ContactList.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:ContactList) > 0">
					<xsl:variable name="root" select="$response//sml:ContactList/*[1]" />
					<xsl:if test="(count($root/@xlink:arcrole) eq 0) and (count($root/@xlink:role) eq 0) ">
						<ctl:message>FAILURE:  That either xlink:arcrole or xlink:role attribute should be present in the member element of ContactList.</ctl:message> 
						<ctl:fail />
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no ContactList element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req56">
		<ctl:param name="response" />
		<ctl:assertion>The typeOf property shall require meaningful values for the xlink:title and xlink:href attributes. 
The uniqueID of the referenced process, given by its gml:identifier property, shall be the value of the xlink:title attribute, 
while a resolvable URL to the reference process description shall be the value of the xlink:href attribute.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate within the XML Instance that an xlink:title and xlink:href are present in any typeOf element of an XML Instance.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:typeOf) > 0">
					<ctl:message>There is one or more "typeOf" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:typeOf">
						<xsl:variable name="typeOf" select="." />
						<xsl:if test="(count($typeOf/@xlink:title) eq 0) or (count($typeOf/@xlink:href) eq 0)">
							<ctl:message>FAILURE: An xlink:title and xlink:href should be present in any typeOf element of an XML Instance. </ctl:message> 
							<ctl:fail />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no typeOf element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req57">
		<ctl:param name="response" />
		<ctl:assertion>Regardless of whether a feature of interest is described inline or provided by reference, the xlink:arcrole attribute of the member property of the FeatureList shall be used to specify the relationship of the associated feature to the process. 
If a unique identifier or name for the feature of interest exists, it shall be the value of the xlink:title of the member property of the FeatureList.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate within the XML Instance that the member property of a FeatureList has a xlink:arcrole attribute present.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:FeatureList) > 0">
					<ctl:message>There is one or more "FeatureList" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:FeatureList">
						<xsl:variable name="member" select="./*[1]" />
						<xsl:if test="(count($member/@xlink:arcrole) eq 0)">
							<ctl:message>FAILURE: An xlink:arcrole should be present in the member property of a FeatureList. </ctl:message> 
							<ctl:fail />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no FeatureList element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req58">
		<ctl:param name="response" />
		<ctl:assertion>The ObservableProperty element shall include the definition attribute that shall take as its value, a resolvable URL referencing the definition of the observable within an online dictionary or ontology.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate within the XML Instance, the presence and resolvability of the definition attribute for any ObservableProperty element.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:ObservableProperty) > 0">
					<ctl:message>There is one or more "sml:ObservableProperty" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:ObservableProperty">
						<xsl:variable name="ObservableProperty" select="." />
						<xsl:if test="(count($ObservableProperty/@definition) eq 0)">
							<ctl:message>FAILURE: The definition attribute should be present in the sml:ObservableProperty element. </ctl:message> 
							<ctl:fail />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:ObservableProperty element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req61">
		<ctl:param name="response" />
		<ctl:assertion>When the values of a DataStream can be referenced by a resolvable URL, that URL shall be the value of of the xlink:href attribute in the value property of the DataStream.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate the presence of an xlink:href atribute with resolvable URL for DataStream values provided by reference.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:outputs//swe:DataStream) > 0">
					<ctl:message>There is one or more "swe:DataStream" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:outputs//swe:DataStream">
						<xsl:variable name="values" select="./swe:values" />
						<xsl:choose>
							<xsl:when test="not(count($values) > 0)">
								<ctl:message>FAILURE: There is no swe:values element in the swe:DataStream. </ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:when test="not(count($values/@xlink:href) > 0)">
								<ctl:message>FAILURE: There is no xlink:href attribute in the swe:values element. </ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:otherwise>
								<ctl:message>PASS: There is a xlink:href attribute in the swe:values element. </ctl:message> 
							</xsl:otherwise>
						</xsl:choose>	
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:ObservableProperty element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req65">
		<ctl:param name="response" />
		<ctl:assertion>When the value of the component property is “byReference”, there shall be meaningful values for the xlink:title and xlink:href attributes. 
The uniqueID of the referenced process, given by its gml:identifier property, shall be the value of the xlink:title attribute, while a resolvable URL 
to the referenced process description shall be the value of the xlink:href attribute.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate the presence of xlink:title and xlink:href for the component property when its value is provided by reference.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:component) > 0">
					<ctl:message>There is one or more "sml:component" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:component">
						<xsl:variable name="component" select="." />
						<xsl:choose>
							<xsl:when test="not($component eq '')">
								<ctl:message>The sml:component value is not provided by reference.</ctl:message> 
							</xsl:when>
							<xsl:otherwise>
								<xsl:if test="(count($component/@xlink:title) eq 0) or (count($component/@xlink:href) eq 0)">
									<ctl:message>FAILURE: An xlink:title and xlink:href should be present in the sml:component element. </ctl:message> 
									<ctl:fail />
								</xsl:if>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:component element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req71">
		<ctl:param name="response" />
		<ctl:assertion>The following rules shall be used for designating the source and destination paths within the Linked element.
a) The path begins at the base of the current process 
b) The path includes only property elements (lowerCamelCase) and not value objects (UpperCamelCase) 
c) If the property has an attribute name and it has a value, then it shall be used; otherwise the unqualified name of the property element should be used 
d) The path can follow properties that are byReference</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate that all paths lead to valid ports.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:connections//sml:Link) > 0">
					<xsl:for-each select="$response//sml:connections//sml:Link">
						<xsl:variable name="Link" select="." />
						<!-- 1.檢查source -->
						<!-- 取得 source 的ref-->
						<xsl:variable name="source" select="$Link/sml:source/@ref" />
						<ctl:message>smlFunctions:checkSourceInResponse($response,$source): <xsl:value-of select="smlFunctions:checkSourceInResponse($response,$source)" />.</ctl:message> 
						<xsl:if test="normalize-space(smlFunctions:checkSourceInResponse($response,$source)) eq ''" >
							<ctl:message>FAILURE: The source ref:"<xsl:value-of select="$source" />" in the Link lead to invalid ports. </ctl:message> 
							<ctl:fail />
						</xsl:if>
						
						<!-- 2.destination -->
						<!-- 取得 destination 的ref-->
						<xsl:variable name="destination" select="$Link/sml:destination/@ref" />
						<ctl:message>smlFunctions:checkDestinationInResponse($response,$destination): <xsl:value-of select="smlFunctions:checkDestinationInResponse($response,$destination)" />.</ctl:message> 
						<xsl:if test="normalize-space(smlFunctions:checkDestinationInResponse($response,$destination)) eq ''" >
							<ctl:message>FAILURE: The destination ref:"<xsl:value-of select="$destination" />" in the Link lead to invalid ports. </ctl:message> 
							<ctl:fail />
						</xsl:if>
						
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:connections element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	
	<ctl:test name="sml:Req74">
		<ctl:param name="response" />
		<ctl:assertion>The attachedTo property shall require meaningful values for the xlink:title and xlink:href attributes. 
The uniqueID of the referenced process, given by its gml:identifier property, shall be the value of the xlink:title attribute, 
while a resolvable URL to the reference process description shall be the value of the xlink:href attribute.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate that the attachedTo property has values for the xlink:href and xlink:title attributes.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:attachedTo) > 0">
					<ctl:message>There is one or more "sml:attachedTo" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:attachedTo">
						<xsl:variable name="attachedTo" select="." />
						<xsl:choose>
							<xsl:when test="(count($attachedTo/@xlink:title) eq 0) or (count($attachedTo/@xlink:href) eq 0)">
								<ctl:message>FAILURE: An xlink:title and xlink:href should be present in the sml:attachedTo element. </ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:otherwise>
								
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:attachedTo element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req75">
		<ctl:param name="response" />
		<ctl:assertion>The position property shall take a swe:DataRecord as its value when both location and orientation are relevant. 
This swe:DataRecord shall consist of two swe:Vector fields, the first for location and the second for orientation.</ctl:assertion>
		<ctl:code>
			<ctl:message>When the position element takes a swe:DataRecord as its value, validate that the DataRecord contains two swe:Vector elements as its fields.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:position/swe:DataRecord) > 0">
					<ctl:message>There is one or more "swe:DataRecord" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:position/swe:DataRecord">
						<xsl:variable name="Vector" select=".//swe:Vector" />
						<xsl:choose>
							<xsl:when test="not(count($Vector) eq 2)">
								<ctl:message>FAILURE: When the position element takes a swe:DataRecord as its value, the DataRecord should contains two swe:Vector elements as its fields. </ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:otherwise>
								
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:DataRecord element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req77">
		<ctl:param name="response" />
		<ctl:assertion>A swe:DataArray describing the trajectory of a moving component shall contain as its elementType a swe:DataRecord 
		that includes a time field plus one or more swe:Vector fields supporting any or all appropriate properties of dynamic state 
		(e.g. location, orientation, linear velocity, linear acceleration, angular velocity, and angular acceleration).</ctl:assertion>
		<ctl:code>
			<ctl:message>When the position element takes a swe:DataArray as its value, validate that the DataArray contains a time field and one or more swe:Vector elements as its fields.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:position/swe:DataArray) > 0">
					<ctl:message>There is one or more "swe:DataArray" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:position/swe:DataArray">
						<xsl:variable name="Time" select=".//swe:Time" />
						<xsl:variable name="Vector" select=".//swe:Vector" />
						<xsl:choose>
							<xsl:when test="not(count($Time) eq 1) or not(count($Vector) > 0)">
								<ctl:message>FAILURE: When the position element takes a swe:DataArray as its value, the DataArray should contains a time field and one or more swe:Vector elements as its fields. </ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:otherwise>
								
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:DataArray element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req81">
		<ctl:param name="response" />
		<ctl:assertion>A Mode shall not set any process property values, other than the values of parameters defined within the same process or its parent processes.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate that setValue references only parameter properties and only parameter properties within the current process or parent process.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:setValue) > 0">
					<ctl:message>There is one or more "sml:setValue" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:setValue">
						<xsl:variable name="ref" select="./@ref" />
						<xsl:choose>
							<xsl:when test="not(starts-with($ref, 'parameters/'))">
								<ctl:message>FAILURE: The setValue should references only parameter properties and only parameter properties within the current process or parent process.</ctl:message> 
								<ctl:fail />
							</xsl:when>
							<xsl:otherwise>
								
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:setValue element in the sensorML, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<ctl:test name="sml:Req82">
		<ctl:param name="response" />
		<ctl:assertion>The parameter values set by a Mode cannot be outside of the values allowed by the AllowedValues property of the parameter.</ctl:assertion>
		<ctl:code>
			<ctl:message>Validate that the parameter values set within Mode are within the appropriate range as defined in the swe:AllowedValues property of that parameter.</ctl:message>
			<xsl:choose>
				<xsl:when test="count($response//sml:modes//sml:setValue) > 0">
					<ctl:message>There is one or more "sml:setValue" element in the sensorML. </ctl:message> 
					<xsl:for-each select="$response//sml:modes//sml:setValue">
						<xsl:variable name="setValue" select="." />
						<xsl:variable name="ref" select="./@ref" />
						<!-- 1.開始處理ref的值切割 -->
						<xsl:variable name="second" select="substring-before(substring-after($ref, '/'), '/')" />
						<xsl:variable name="third" select="substring-after(substring-after($ref, '/'), '/')" />
						<!-- 2.開始檢查 
						<xsl:variable name="AllowedValues" select="$response//sml:parameters//sml:parameter[@name='string($second)']//swe:field[@name='string($third)']//swe:AllowedValues" />-->
						<xsl:variable name="AllowedValues" select="smlFunctions:findAllowedValues($response,$second,$third)" />
						<ctl:message>setValue: <xsl:value-of select="$setValue" />.</ctl:message> 
						<ctl:message>AllowedValues: <xsl:value-of select="$AllowedValues" />.</ctl:message> 
						<xsl:choose>
							<xsl:when test="count($AllowedValues/swe:interval) > 0">
								<ctl:message>checkStringInInterval: <xsl:value-of select="smlFunctions:checkStringInInterval($setValue,$AllowedValues)" />.</ctl:message> 
								<!-- 檢查至少有一組符合 -->
								<xsl:if test="normalize-space(smlFunctions:checkStringInInterval($setValue,$AllowedValues)) eq ''">
									<ctl:message>FAILURE: The parameter values set within Mode should be within the appropriate range as defined in the swe:AllowedValues property of that parameter.</ctl:message> 
									<ctl:fail />
								</xsl:if>
							</xsl:when>
							<xsl:when test="count($AllowedValues/swe:value) > 0">
								<ctl:message>checkStringInValue: <xsl:value-of select="smlFunctions:checkStringInValue($setValue,$AllowedValues)" />.</ctl:message> 
								<!-- 檢查至少有一組符合 -->
								<xsl:if test="normalize-space(smlFunctions:checkStringInValue($setValue,$AllowedValues)) eq ''">
									<ctl:message>FAILURE: The parameter values set within Mode should be within the appropriate range as defined in the swe:AllowedValues property of that parameter.</ctl:message> 
									<ctl:fail />
								</xsl:if>
							</xsl:when>
							<xsl:otherwise>
								<ctl:message>message: NO!!!.</ctl:message> 
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>There is no sml:modes in the sensorML or no sml:setValue element in the sml:modes element, pass this test. </ctl:message> 
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:test>

	<!-- Functions -->
	<ctl:function name="smlFunctions:checkSourceInResponse">
		<ctl:param name="response">response.</ctl:param>
		<ctl:param name="source">source ref</ctl:param>
		<ctl:description>If response contains source ref path, return 1 </ctl:description>
		<ctl:code>
			<!-- 先切割 sourece (不確定有幾個,先預設最多四個) -->
			<xsl:variable name="first" select="substring-before($source, '/')" />
			<xsl:variable name="second">
				<xsl:choose>
					<xsl:when test="contains(substring-after($source, '/'),'/')">
						<xsl:value-of select="substring-before(substring-after($source, '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="substring-after($source, '/')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="third">
				<xsl:choose>
					<xsl:when test="contains(substring-after($source, '/'),'/')">
						<xsl:value-of select="substring-before(substring-after(substring-after($source, '/'), '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="''"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="fourth">
				<xsl:choose>
					<xsl:when test="contains(substring-after($source, '/'),'/')">
						<xsl:value-of select="substring-after(substring-after(substring-after($source, '/'), '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="''"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:for-each select="$response/*">
				<xsl:variable name="firstnode" select="." />
				<xsl:if test="local-name-from-QName(node-name($firstnode)) eq $first">
					<xsl:for-each select="$firstnode//*">
						<xsl:variable name="secondnode" select="." />
						<xsl:if test="$secondnode/@name eq $second">
							<xsl:choose>
								<xsl:when test="not($third eq '')">
									<xsl:for-each select="$response//*">
										<xsl:variable name="thirdnode" select="." />
										<xsl:if test="local-name-from-QName(node-name($thirdnode)) eq $third">
											<xsl:for-each select="$response//*/@name">
												<xsl:variable name="fourthnode" select="." />
												<xsl:if test="$fourthnode eq $fourth">
													<xsl:value-of select="1"/>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="1"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:if>
					</xsl:for-each>
				</xsl:if>
			</xsl:for-each>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="smlFunctions:checkDestinationInResponse">
		<ctl:param name="response">response.</ctl:param>
		<ctl:param name="destination">destination ref</ctl:param>
		<ctl:description>If response contains destination ref path, return 1 </ctl:description>
		<ctl:code>
			<!-- 先切割 destination (假設只有四個) -->
			<xsl:variable name="first" select="substring-before($destination, '/')" />
			<xsl:variable name="second">
				<xsl:choose>
					<xsl:when test="contains(substring-after($destination, '/'),'/')">
						<xsl:value-of select="substring-before(substring-after($destination, '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="substring-after($destination, '/')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="third">
				<xsl:choose>
					<xsl:when test="contains(substring-after($destination, '/'),'/')">
						<xsl:value-of select="substring-before(substring-after(substring-after($destination, '/'), '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="''"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:variable name="fourth">
				<xsl:choose>
					<xsl:when test="contains(substring-after($destination, '/'),'/')">
						<xsl:value-of select="substring-after(substring-after(substring-after($destination, '/'), '/'), '/')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="''"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:for-each select="$response/*">
				<xsl:variable name="firstnode" select="." />
				<xsl:if test="local-name-from-QName(node-name($firstnode)) eq $first">
					<xsl:for-each select="$firstnode//*">
						<xsl:variable name="secondnode" select="." />
						<xsl:if test="$secondnode/@name eq $second">
							<xsl:choose>
								<xsl:when test="not($third eq '')">
									<xsl:for-each select="$response//*">
										<xsl:variable name="thirdnode" select="." />
										<xsl:if test="local-name-from-QName(node-name($thirdnode)) eq $third">
											<xsl:for-each select="$response//*/@name">
												<xsl:variable name="fourthnode" select="." />
												<xsl:if test="$fourthnode eq $fourth">
													<xsl:value-of select="1"/>
												</xsl:if>
											</xsl:for-each>
										</xsl:if>
									</xsl:for-each>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="1"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:if>
					</xsl:for-each>
				</xsl:if>
			</xsl:for-each>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="smlFunctions:isValidURL">
        <ctl:param name="uriString">The URL to validate</ctl:param>
        <ctl:return>True/False depending on whether or not the URL is valid</ctl:return>
        <ctl:description>Determines if a URL is valid</ctl:description>
       <ctl:code>
 			<xsl:variable name="urlRegex" select="'^((http|https|ftp|file):((//)|(\\\\))[\w\d:#%/;$()~_?\-=\\\.&amp;]*)'"/>
			<xsl:value-of select="(matches($uriString, $urlRegex,'i'))"/>
        </ctl:code>
    </ctl:function>
	
	<ctl:function name="smlFunctions:findAllowedValues">
		<ctl:param name="response">response</ctl:param>
		<ctl:param name="second">second</ctl:param>
		<ctl:param name="third">third</ctl:param>
		<ctl:description></ctl:description>
		<ctl:code>
			
			<xsl:for-each select="$response//sml:parameters//sml:parameter">
				<xsl:variable name="parameter" select="." />
				<xsl:variable name="parameterName" select="./@name" />
				<xsl:if test="$parameterName eq $second">
					<xsl:for-each select="$parameter//swe:field">
						<xsl:variable name="field" select="." />
						<xsl:variable name="fieldName" select="./@name" />
							<xsl:if test="$fieldName eq $third">
								<xsl:copy-of select="$field//swe:AllowedValues" />
							</xsl:if>
					</xsl:for-each>
				</xsl:if>
			</xsl:for-each>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="smlFunctions:checkStringInInterval">
		<ctl:param name="value">the value which need to be check.</ctl:param>
		<ctl:param name="AllowedValues">AllowedValues</ctl:param>
		<ctl:description>If value contains in Interval of the AllowedValues, return 1 </ctl:description>
		<ctl:code>
			<xsl:for-each select="$AllowedValues/swe:interval">
				<xsl:variable name="interval" select="." />
				<xsl:variable name="first" select="substring-before($interval, ' ')" />
				<xsl:variable name="last" select="substring-after($interval, ' ')" />
				<xsl:if test="not(number($first) > number($value)) and not(number($value) > number($last))">
					<xsl:value-of select="1"/>
				</xsl:if>
			</xsl:for-each>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="smlFunctions:checkStringInValue">
		<ctl:param name="value">the value which need to be check.</ctl:param>
		<ctl:param name="AllowedValues">AllowedValues</ctl:param>
		<ctl:description>If value contains in Value of the AllowedValues, return 1 </ctl:description>
		<ctl:code>
			<xsl:for-each select="$AllowedValues/swe:value">
				<xsl:variable name="tmpValue" select="." />
				<xsl:if test="$tmpValue eq $value">
					<xsl:value-of select="1"/>
				</xsl:if>
			</xsl:for-each>
		</ctl:code>
	</ctl:function>
</ctl:package>